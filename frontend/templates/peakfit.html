{% extends "_common.html" %}
{% block head_matter %}
<script src="//cdnjs.cloudflare.com/ajax/libs/chosen/1.1.0/chosen.jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/chosen/1.1.0/chosen.min.css">
<script type="text/javascript">
function new_get_dataset(info) {
  old_get_dataset(info);
  if (info == '') return;
  var parts = info.split(',');
  var post_data = {name: parts[0], kind: parts[1]};
  $('#ds_filter_container').load('/_dataset_filterer', post_data, function(){
    ds_name = parts[0];
    ds_kind = parts[1];
  });
}
old_get_dataset = get_dataset;
get_dataset = new_get_dataset;
function collect_peakfit_args(alg) {
  var bounds = $('input[name=peakrange]').map(
      function(i,e){return +e.value;}).toArray();
  return {
    lb: bounds[0], ub: bounds[1], alg: alg,
    basetype: $('input[name=basetype]:checked').val(),
    xres: $('#xres').val(), fitloc: $('#peakloc').val(),
    fitkind: $('input[name=peaktype]:checked').val(),
    locfixed: +($('label[for=locfixed]').attr('aria-pressed') == "true"),
    ds_kind: ds_kind, ds_name: ds_name
  };
}
function do_batch_download() {
  var alg = $('input[name=batch_algo]:checked').val();
  var args = collect_peakfit_args(alg);
  args['include_metadata'] = +$('#batch_meta').is(':checked');
  var url = '/'+fig.id+'/peak_area.csv?'+$.param(args);
  window.open(url, '_blank');
}
function fmt_number(x) {
  var s = x.toFixed(2);
  if (s === '0.00') {
    s = x.toExponential(2);
  }
  return s
}
function do_peakfit(alg) {
  var post_data = collect_peakfit_args(alg);
  post_data['fignum'] = fig.id;
  $('#fit_result').hide();
  $.post('/_peak', post_data, function(data, status) {
    if (status !== 'success') return;
    var area = fmt_number(data['area']);
    var height = fmt_number(data['height']);
    var center = '', fwhm = '';
    if ('area_std' in data) {
      area += ' ± ' + fmt_number(data['area_std']);
    }
    if ('height_std' in data) {
      height += ' ± ' + fmt_number(data['height_std']);
    }
    if ('center' in data) {
      center = fmt_number(data['center'])+' ± '+fmt_number(data['center_std']);
    }
    if ('fwhm' in data) {
      fwhm = fmt_number(data['fwhm']) + ' ± ' + fmt_number(data['fwhm_std']);
    }
    $('#fit_area').text(area);
    $('#fit_height').text(height);
    $('#fit_center').text(center);
    $('#fit_fwhm').text(fwhm);
    $('#fit_result').show();
  }, 'json');
}
$(document).ready(function(){
  $('#blr_pp_steps').toggle();
  $('#locfixed').button();
  onready_boilerplate("{{ws_uri}}", {{ fig_id }});
  // make the blr/pp interactive
  var table = $('#blr_pp_steps>table');
  table.find('tr').slice(0,3).find('select,input').change(function(){
    do_baseline(table);
    do_pp(collect_pp_args(table));
  });
  var pp_watcher = new MutationObserver(function(){
    do_pp(collect_pp_args(table));
  });
  pp_watcher.observe(table.find('.pp_staging')[0],
                     {childList: true, subtree: true});
  // Also set peakfit params when manual zooming.
  $('#zoom_control button').click(function(){
    var bounds = $('input[name=peakrange]');
    bounds[0].value = $('#zoom_control input[name=xmin]').val();
    bounds[1].value = $('#zoom_control input[name=xmax]').val();
    $('#peakloc').val(bounds[0].value/2.0 + bounds[1].value/2.0);
  });
});
</script>
<style type="text/css">
#ds_selector_wrapper { padding-top: 1em; }
#lhs { float: left; }
#fig_wrapper { clear: none; float: left; padding: 0 2em; display: inline-block;}
#fit_result { float: right; margin-right: 1em; }
#fit_result td { padding: 0.2em 1em; }
#fit_result td:last-child { text-align: right; }
label[for=locfixed]>span:after { content: "approx." }
label[for=locfixed].ui-state-active>span:after { content: "fixed" }
</style>
{% end %}

{% block body_matter %}
{% include '_dataset_selector.html' %}

<div id='lhs'>
<p>
(Optional) apply baseline correction / preprocessing:
<button onclick="$('#blr_pp_steps').toggle()">show/hide table</button>
<div id='blr_pp_steps'>
{% include '_blr_pp_table.html' %}
</div>
</p>

<div id="peak_steps">
<table class="pp_table">
<tr class="uline"><th colspan=3>Peak Fitting Algorithms</th></tr>
<!-- manual peak -->
<tr><td class="rline vcenter" rowspan=2>
<button class="needs_plot" onclick="do_peakfit('manual');" disabled>Manual</button></td>
<td colspan=2>Peak range:
<input type="text" name="peakrange" value="0.0" size=5> -
<input type="text" name="peakrange" value="1000.0" size=5>
</td></tr>
<tr class="uline"><td colspan=2>Peak bottom:
<label><input type="radio" name="basetype" value="endpoint" checked>min(endpoints)</label>
<label><input type="radio" name="basetype" value="region">min(region)</label>
</td></tr>
<!-- peak fitting -->
<tr><td class="uline rline vcenter" rowspan=3>
<button class="needs_plot" onclick="do_peakfit('fit');" disabled>Fit Peak</button></td>
<td colspan=2>Peak location:
<input type="text" id="peakloc" value="500.0" size=5>
<input type="checkbox" id="locfixed" /><label for="locfixed"></label>
</td></tr>
<tr><td colspan=2>x-axis resolution:
<input type="text" id="xres" value="1.0" size=5> (approx.)
</td></tr>
<tr class="uline"><td colspan=2>Peak type:
<label><input type="radio" name="peaktype" value="lorentzian" checked>Lorentzian</label>
<label><input type="radio" name="peaktype" value="gaussian">Gaussian</label>
</td></tr>
</table>
</div>

<table id='fit_result' style='display: none'>
<tr class='uline'><th class='bold' colspan=2>Fitted Peak</th></tr>
<tr><td class='rline'>Height</td><td id='fit_height'></td></tr>
<tr><td class='rline'>Center</td><td id='fit_center'></td></tr>
<tr><td class='rline'>FWHM</td><td id='fit_fwhm'></td></tr>
<tr><td class='rline'>Area</td><td id='fit_area'></td></tr>
</table>

</div>  <!-- lhs -->

<div id="fig_wrapper">
<div id="figure"></div>
<br style="clear:both">
{% include '_zoom_control.html' %}
</div>

<!-- batch mode -->
<div style="clear:both">
<b>Batch Mode</b>
<p>
Download all peak data for the filtered subset using the settings above.
</p>
<div id='ds_filter_container'></div>

<div>
Algorithm type:
<label><input type="radio" name="batch_algo" value="manual" checked>Manual</label>
<label><input type="radio" name="batch_algo" value="fit">Fitted</label>
<br />
<label>Include metadata: <input type="checkbox" id="batch_meta"></label>
<br />
<button class="needs_filter" onclick="do_batch_download();" disabled>
Download peak data</button>
</div>
</div>

{% end %}
