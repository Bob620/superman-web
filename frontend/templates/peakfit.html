{% extends "_common.html" %}
{% block head_matter %}
<script src="//cdnjs.cloudflare.com/ajax/libs/chosen/1.1.0/chosen.jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/chosen/1.1.0/chosen.min.css">
<script type="text/javascript">
// XXX hacks! Overwrites the generic get_dataset to add peakfit-specific logic.
get_dataset = function(info) {
  if (info == '') return;
  var parts = info.split(',');
  ds_name = parts[0];
  ds_kind = parts[1];
  var post_data = {
    name: ds_name, kind: ds_kind, fignum: fig.id
  };
  function do_select(name, idx) {
    $('#upload_messages').text("Selecting...").fadeIn();
    var data = {
      name: name, idx: idx, ds_name: ds_name, ds_kind: ds_kind, fignum: fig.id
    };
    $.ajax({
      url: '/_select', type: 'POST', data: data, dataType: 'json',
      error: upload_cbs['fail'],
      success: function(data, status) {
        upload_cbs['success'](data, status);
        autofill_peakfit_params();
      }
    });
  }
  $('#spinner').show();
  $('#selector').load('/_dataset_selector', post_data, function(){
    $('#spinner').hide();
    // If we have a numeric spinner
    $("#selector input").change(function(evt){
      do_select(undefined, evt.target.value)
    });
    // If we have a chosen <select> dropdown
    $("#selector .chosen-select").chosen({search_contains: true}).change(
    function(evt){
      if (evt.target.value.length > 0) {
        do_select(evt.target.value, undefined);
      }
    }).next().css('width', '+=15');
    // toggle .libs_only elements
    $('.libs_only').toggle(ds_kind === 'LIBS');
  });
  // also load the ds filters
  $('#ds_filter_container').load('/_dataset_filterer', {
    name: ds_name, kind: ds_kind});
}

function collect_peakfit_args(alg) {
  var bounds = $('input[name=peakrange]').map(
      function(i,e){return +e.value;}).toArray();
  return {
    lb: bounds[0], ub: bounds[1], alg: alg,
    basetype: $('#basetype').val(),
    xres: $('#xres').val(),
    fitloc: $('#peakloc').val(),
    fitkind: $('#peaktype').val(),
    locfixed: +($('label[for=locfixed]').attr('aria-pressed') == "true"),
    ds_kind: ds_kind, ds_name: ds_name
  };
}
function do_batch_download() {
  var alg = $('input[name=batch_algo]:checked').val();
  var args = collect_peakfit_args(alg);
  args['include_metadata'] = +$('#batch_meta').is(':checked');
  var url = '/'+fig.id+'/peak_area.csv?'+$.param(args);
  window.open(url, '_blank');
}
function fmt_number(x) {
  if (x === undefined) {
    return 'N/A';
  }
  var s = x.toFixed(2);
  if (s === '0.00') {
    s = x.toExponential(2);
  }
  return s;
}
function do_peakfit(alg) {
  var post_data = collect_peakfit_args(alg);
  post_data['fignum'] = fig.id;
  $('#fit_result').hide();
  $.post('/_peak', post_data, function(data, status) {
    if (status !== 'success') return;
    var area = fmt_number(data['area']);
    var height = fmt_number(data['height']);
    var center = '', fwhm = '';
    if ('area_std' in data) {
      area += ' ± ' + fmt_number(data['area_std']);
    }
    if ('height_std' in data) {
      height += ' ± ' + fmt_number(data['height_std']);
    }
    if ('center' in data) {
      center = fmt_number(data['center'])+' ± '+fmt_number(data['center_std']);
    }
    if ('fwhm' in data) {
      fwhm = fmt_number(data['fwhm']) + ' ± ' + fmt_number(data['fwhm_std']);
    }
    $('#fit_area').text(area);
    $('#fit_height').text(height);
    $('#fit_center').text(center);
    $('#fit_fwhm').text(fwhm);
    $('#fit_result').show();
    if ('axis_limits' in data) {
      update_zoom_ctrl(data['axis_limits']);
    }
  }, 'json');
}
function autofill_peakfit_params() {
  var bounds = $('input[name=peakrange]');
  bounds[0].value = $('#zoom_control input[name=xmin]').val();
  bounds[1].value = $('#zoom_control input[name=xmax]').val();
  $('#peakloc').val(bounds[0].value/2.0 + bounds[1].value/2.0);
}
$(document).ready(function(){
  $('#blr_pp_steps').toggle();
  $('#locfixed').button();
  onready_boilerplate("{{ws_uri}}", {{ fig_id }});
  // make the blr/pp interactive
  var table = $('#blr_pp_steps>table');
  table.find('tr').slice(0,3).find('select,input').change(function(){
    do_baseline(table);
    do_pp(collect_pp_args(table));
  });
  var pp_watcher = new MutationObserver(function(){
    do_pp(collect_pp_args(table));
  });
  pp_watcher.observe(table.find('.pp_staging')[0],
                     {childList: true, subtree: true});
  // Also set peakfit params when manual zooming.
  $('#zoom_control input[type=submit]').click(autofill_peakfit_params);
});
</script>
<style type="text/css">
#ds_selector_wrapper { padding-top: 1em; }
#lhs { float: left; }
#fig_wrapper { clear: none; float: left; padding: 0 2em; display: inline-block;}
#fit_result { float: right; }
#fit_result td { padding: 0.2em 1em; }
#fit_result td:last-child { text-align: right; }
#peakfit_params td.ralign { text-align: right; padding-right: 0; }
#peakfit_params td:last-child { text-align: left; }
label[for=locfixed]>span:after { content: "approx." }
label[for=locfixed].ui-state-active>span:after { content: "fixed" }
</style>
{% end %}

{% block body_matter %}
{% include '_dataset_selector.html' %}

<div id='lhs'>
<div>
(Optional) apply baseline correction / preprocessing:
<button onclick="$('#blr_pp_steps').toggle()">show/hide table</button>
<div id='blr_pp_steps'>
{% include '_blr_pp_table.html' %}
</div>
</div>

<table id="peakfit_params" class="pp_table">
<thead>
<tr class="uline"><th colspan=3>Peak Fitting Algorithms</th></tr>
</thead>
<tbody>
<!-- manual peak -->
<tr><td class="rline vcenter" rowspan=2>
<button class="needs_plot" onclick="do_peakfit('manual');" disabled>Manual</button></td>
<td class="ralign">Peak range</td><td>
<input type="text" name="peakrange" value="0.0" size=5> -
<input type="text" name="peakrange" value="1000.0" size=5>
</td></tr>
<tr class="uline"><td class="ralign">Peak bottom</td><td>
<select id="basetype">
  <option value="endpoint">min(endpoints)</option>
  <option value="region">min(region)</option>
</select></td></tr>
<!-- peak fitting -->
<tr><td class="uline rline vcenter" rowspan=3>
<button class="needs_plot" onclick="do_peakfit('fit');" disabled>Automatic</button></td>
<td class="ralign">Peak location</td><td>
<input type="text" id="peakloc" value="500.0" size=5>
<input type="checkbox" id="locfixed" /><label for="locfixed"></label>
</td></tr>
<tr><td class="ralign">x-axis resolution</td><td>
<input type="text" id="xres" value="1.0" size=5> (approx.)
</td></tr>
<tr class="uline"><td class="ralign">Peak type</td><td>
<select id="peaktype">
  <option value="lorentzian">Lorentzian</option>
  <option value="gaussian">Gaussian</option>
</select></td></tr>
</tbody></table>

</div>  <!-- lhs -->

<div id="fig_wrapper">
<div id="figure"></div>
<table id='fit_result' style='display: none'>
<tr class='uline'><th class='bold' colspan=2>Peak Parameters</th></tr>
<tr><td class='rline'>Height</td><td id='fit_height'></td></tr>
<tr><td class='rline'>Center</td><td id='fit_center'></td></tr>
<tr><td class='rline'>FWHM</td><td id='fit_fwhm'></td></tr>
<tr><td class='rline'>Area</td><td id='fit_area'></td></tr>
</table>
<br style="clear:both">
{% include '_zoom_control.html' %}
</div>

<!-- batch mode -->
<div style="clear:both">
<b>Batch Mode</b>
<p>
Download all peak data for the filtered subset using the settings above.
</p>
<div id='ds_filter_container'></div>

<div>
Algorithm type:
<label><input type="radio" name="batch_algo" value="manual" checked>Manual</label>
<label><input type="radio" name="batch_algo" value="fit">Automatic</label>
<br />
<label>Include metadata: <input type="checkbox" id="batch_meta"></label>
<br />
<button class="needs_filter" onclick="do_batch_download();" disabled>
Download peak data</button>
</div>
</div>

{% end %}
